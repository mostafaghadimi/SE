
	\سؤال{}
	
	\textbf{فرض کنید امروز در شرکتتان محصولی نرم‌افزاری ایجاد کرده و به مشتری فروخته‌اید. سی سال بعد وضعیت نرم‌افزار شما چگونه خواهد بود؟ آیا هنوز مشتری شما از نرم‌افزار استفاده می‌کند؟ اگر چنین است شما در طول این زمان چه کارهایی روی نرم‌افزار انجام داده‌اید؟ اگر از نرم‌افزار شما استفاده نمی‌شود به نظرتان چه دلایلی موجب این اتفاق شده است؟}
	
	\begin{itemize}
		\item 
		الف و ب) وضعیت نرم‌افزار در آینده، به عوامل زیادی بستگی  دارد که از مهم‌ترین آن‌ها می‌توان به نوع قرارداد، متدولوژی مورد استفاده و نحوه‌پیاده‌سازی اشاره کرد. برای وضعیت نرم‌افزار نیز چندین حالت می‌توان داشت:
		
		\begin{enumerate}
			\item نرم‌افزار به خوبی کار می‌کند و قابلیت اضافه کردن ویژگی‌\footnote{feature}های جدید به آن وجود دارد.
			\item 
			نرم‌افزار کار می‌کند اما قابلیت کم یا زیاد کردن ویژگی به آن وجود ندارد. اصطلاحا به این سیستم، سیستم «مُرده» می‌گویند. 
			\item 
			نرم‌افزار کار نمی‌کند.
		\end{enumerate}
		\textbf{نکته:} نباید پشتیبانی را با نگهداری اشتباه کرد. در پشتیبانی تغییری در کد داده نمی‌شود و هدف از آن بالا نگه داشتن سیستم است. برای مثال موارد 
		\begin{itemize}
			\item \lr{logging}
			\item نسخه‌ی بازگردانی\footnote{restore}
			\item نسخه‌ی پشتیبان\footnote{backup}
			\item و...
		\end{itemize}
		از جمله موارد پشتیبانی به حساب می‌آیند اما در نگهداری منبع کد دست‌کاری می‌شود و برای بالا نگه داشتن سیستم، تغییر روی آن اعمال می‌شود.
	\item 
	پ) در صورتی که نرم‌افزار کار کند و قابلیت اضافه کردن ویژگی‌های جدید یا تغییر در آن وجود داشته باشد، این نرم‌افزار دارای قابلیت نگهداری \footnote{maintenance}دارد. \footnote{دشواری این کار بسیار وابسته به نوع متدولوژی و نحوه پیاده‌سازی است؛ زیرا اگر \lr{Coupling} بالا و \lr{Cohesion} کم باشد، کار نگهداری نرم‌افزار  بسیار سخت می‌شود.} در حالت کلی ۴ نوع نگهداری داریم:
		\begin{enumerate}
			\item \lr{Perfective Maintenance}: در این نوع از نگهداری به سیستم قابلیت‌هایی را اضافه کنیم.
			\item 
			\lr{Corrective Maintenance}: در این نوع از نگهداری مشکل\footnote{bug}  یک قابلیت را برطرف می‌کنیم.
			\item 
			\lr{Adaptive Maintenance}: در نوع از نگهداری سیستم را با پلتفرم جدید تطبیق و تغییر می‌دهیم.
			\item 
			\lr{Preventive Maintenance}: در این نوع از نگهداری برای اجتناب از بروز یک مشکل در آینده، تغییری در سیستم ایجاد می‌کنیم.
		\end{enumerate}
	در روش‌های گوناگون، سیاست‌های متفاوتی برای ویژگی نگهداری وجود دارد که عبارتند از:
		\begin{enumerate}
			\item 
			سیاست مقیم\footnote{resident}. قراردادی نوشته می‌شود تا به صورت مداوم سیستم نگهداری شود.
			\item 
			سیاست \lr{on-demand}. این سیاست به این معنی است که هر موقع سیستم دچار اشکال شد و یا کارفرما ویژگی جدیدی را خواست، از سیستم نگهداری می‌شود.
			\item 
			سیاست دوره‌ای\footnote{periodical}. این سیاست به این معنی است که از سیستم در بازه‌های زمانی مشخص نگهداری می‌شود.
		\end{enumerate}
	\item 
	ت) دلیل استفاده نشدن از نرم‌افزار ما، نداشتن قابلیت نگهداری و به اصطلاح «مُرده» بودن سیستم است. چند عامل ممکن است در از بین رفتن قابلیت نگهداری سیستم، تاثیر به سزایی داشته باشند؛ این عوامل عبارتند از:
	 	\begin{enumerate}
	 		\item
	 		در صورتی که منبع کد به صورت نابهینه و بدون در نظر گرفتن الگوهای طراحی نرم‌افزار\footnote{design pattern} و \lr{bad smell}ها پیاده‌سازی شوند، تکثیر\footnote{duplication} در کد بسیار بالا خواهد بود. این تکثیر باعث بالا رفتن \lr{coupling} و در نتیجه پایین آمدن \lr{cohesion} می‌شود.
	 		\item 
	 		نوع قرارداد و متدولوژی در مرحله ایجاد و توسعه نرم‌افزار. ممکن است کارفرما با توجه به شرابطی که وجود دارد، پروژه و محدودیت‌های زمانی و مالی را طوری تعریف کند که ویژگی نگهداری برایش اهمیت کم‌تری داشته باشد.
	 		
	 		\item 
	 		وجود کلاس \lr{God}. به کلاسی کلاس \lr{God} گفته می‌شود که ویژگی‌ها و عمل‌کرد‌های زیادی در آن پیاده‌سازی شود در حالی که آن کلاس قابل شکسته شدن به کلاس‌های کوچک‌تر باشد.
	 		\item 
	 		وجود دید ترایا. \footnote{Message Chain} اگر همه‌ی دید‌ها در روابط به صورت دوطرفه تعریف شود در حالی‌که به آن نیاز نیست، باعث به وجود آمدن این عارضه می‌شود.
	 	\end{enumerate}
 	
 	همان‌طور که مشخص است، ویژگی نگهداری را می‌توان به عنوان مهم‌ترین ویژگی در ایجاد و توسعه نرم‌افزار محسوب کرد؛ به همین دلیل، در اکثر متدولوژی‌ها بیش‌ترین هزینه و زمان صرف محقق کردن این ویژگی می‌شود.
	\end{itemize}